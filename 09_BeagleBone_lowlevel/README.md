<h1 align="center">
    BBB with I2C Low-Level Driver for MPU6050 as Platform Device
</h1>

[Previous Example's README](../07_BeagleBone/README.md) applies here as well, since this project is very similar. However, the I2C bus is managed through low-level primitives directly interfacing with the I2C controller registers, rather than using the higher-level I2C subsystem. This allows for more granular control over the I2C operations. It is mainly for educational purposes.

One theoretical aspect worth noting is that the IRQs generated by the I2C controller for RX and TX events are level-triggered. This means that the interrupt line remains asserted as long as the condition that triggered the interrupt persists. Therefore, it is crucial to handle these interrupts promptly and clear the corresponding status bits in the I2C_IRQSTATUS register to prevent the interrupt from continuously firing. Failing to do so can lead to a situation where the CPU is overwhelmed with repeated interrupts, potentially causing system instability or unresponsiveness.

A global variable is used to handle data transfers (`xfers`). During a read/write operation a `mutex` is locked to prevent concurrent access. The interrupt handler processes the data transfer in chunks, updating the `xfers` structure accordingly. Once the transfer is complete, the mutex is unlocked, allowing other operations to proceed. This ensures thread-safe access to the I2C bus and prevents data corruption during simultaneous read/write requests.

Also, the driver is set to `TASK_UNINTERRUPTIBLE` state during transfers to avoid being interrupted by signals, which could lead to inconsistent states or data corruption.

This is done by the function `wait_for_completion_timeout` which internally is the same as:
`return wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);` [ref](https://elixir.bootlin.com/linux/v6.12/source/kernel/sched/completion.c#L152).
